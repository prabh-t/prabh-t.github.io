<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ParTree</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_ParTree.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption" class="empty">&nbsp;</p></div><div id="content"><div id="module-header"><p class="caption">ParTree</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Type Definition
</a></li><li><a href="#g:2">Basics
</a></li><li><a href="#g:3">Parallel operations
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Author : Prabhat Totoo 2011
</p><p>A binary leaf tree data structure with parallel operations.
</p><p>Elements are placed on leaves and the inner nodes store the size
 of the subtree beneath it.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Tree">Tree</a> a<ul class="subs"><li>= <a href="#v:Leaf">Leaf</a> a  </li><li>| <a href="#v:Node">Node</a> !Int !(<a href="ParTree.html#t:Tree">Tree</a> a) !(<a href="ParTree.html#t:Tree">Tree</a> a)  </li></ul></li><li class="src short"><a href="#v:size">size</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; Int</li><li class="src short"><a href="#v:link">link</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a</li><li class="src short"><a href="#v:treeToList">treeToList</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; [a]</li><li class="src short"><a href="#v:treeMap">treeMap</a> ::  (a -&gt; b) -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> b</li><li class="src short"><a href="#v:treeFold">treeFold</a> :: NFData a =&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; a</li><li class="src short"><a href="#v:treeElem">treeElem</a> :: Eq a =&gt; a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; Bool</li><li class="src short"><a href="#v:treeReverse">treeReverse</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a</li><li class="src short"><a href="#v:treeMin">treeMin</a> :: Ord a =&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; a</li></ul></div><div id="interface"><h1 id="g:1">Type Definition
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Tree" class="def">Tree</a> a </p><div class="doc"><p>New data type for Tree with strictness annotations in the definition.
</p><pre> data Tree a = Leaf a | Node !Int !(Tree a) !(Tree a)
</pre><p>For example, a tree representation for the list [1,2,3,4]
</p><pre> myTree = (Node 4 (Node 2 (Leaf 1) (Leaf 2)) (Node 2 (Leaf 3) (Leaf 4)))
</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Leaf" class="def">Leaf</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Node" class="def">Node</a> !Int !(<a href="ParTree.html#t:Tree">Tree</a> a) !(<a href="ParTree.html#t:Tree">Tree</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Tree" class="caption collapser" onclick="toggleSection('i:Tree')">Instances</p><div id="section.i:Tree" class="show"><table><tr><td class="src">Show a =&gt; Show (<a href="ParTree.html#t:Tree">Tree</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">NFData a =&gt; NFData (<a href="ParTree.html#t:Tree">Tree</a> a)</td><td class="doc"><p>This allows for Tree to be evaluated to normal form.
</p></td></tr></table></div></div></div><h1 id="g:2">Basics
</h1><div class="top"><p class="src"><a name="v:size" class="def">size</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; Int</p><div class="doc"><p>Find the size of a tree.
</p></div></div><div class="top"><p class="src"><a name="v:link" class="def">link</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a</p><div class="doc"><p>Link two trees, one to the left and one to the right, making a node.
</p></div></div><h1 id="g:3">Parallel operations
</h1><div class="doc"><p>All operations that follow are parallel implementations.
</p></div><div class="top"><p class="src"><a name="v:treeToList" class="def">treeToList</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; [a]</p><div class="doc"><p>Convert a tree to list.
</p></div></div><div class="top"><p class="src"><a name="v:treeMap" class="def">treeMap</a> ::  (a -&gt; b) -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> b</p><div class="doc"><p>Map a function <code>f</code> to each element of the tree in parallel, producing a
 new tree. Similar to <code>map</code> function in standard and <code>parMap</code> for its parallel 
 equivalent.
</p></div></div><div class="top"><p class="src"><a name="v:treeFold" class="def">treeFold</a> :: NFData a =&gt; (a -&gt; a -&gt; a) -&gt; a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; a</p><div class="doc"><p>Parallel <code>fold</code> function on tree. The first function passed as argument
 needs to be both associative and commutative, e.g. sum and product operators.
 Both have type def <code>Num a =&gt; a -&gt; a -&gt; a</code>
</p></div></div><div class="top"><p class="src"><a name="v:treeElem" class="def">treeElem</a> :: Eq a =&gt; a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; Bool</p><div class="doc"><p>Check if there is any occurrence of the element in the tree. 
 Search proceeds by inspecting subtrees e.g. left and right
 branches in parallel.
</p></div></div><div class="top"><p class="src"><a name="v:treeReverse" class="def">treeReverse</a> ::  <a href="ParTree.html#t:Tree">Tree</a> a -&gt; <a href="ParTree.html#t:Tree">Tree</a> a</p><div class="doc"><p>Reverse all the elements in the tree.
</p></div></div><div class="top"><p class="src"><a name="v:treeMin" class="def">treeMin</a> :: Ord a =&gt; <a href="ParTree.html#t:Tree">Tree</a> a -&gt; a</p><div class="doc"><p>Return the smallest element from the tree.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.9.2</p></div></body></html>